#vulnerability_1.py
from selenium import webdriver
from selenium.webdriver.firefox.options import Options
import concurrent.futures
import re
import time

def scan_payload(payload_url):
    max_retries = 3

    for retry in range(1, max_retries + 1):
        try:
            options = Options()
            options.headless = True
            driver = webdriver.Firefox(options=options)

            try:
                driver.get(payload_url)
                response_text = driver.page_source[:10000]

                if not isinstance(response_text, str) or not response_text:
                    print(f'Error: response text is empty or not a string for {payload_url}')
                    return None

                if re.search(r'sql error|syntax error', response_text, re.IGNORECASE):
                    return payload_url

                break  # Break out of the loop if successful

            except Exception as e:
                print(f'Retry {retry}/{max_retries}: {e}')
                time.sleep(10 * retry)  # Increase the delay before retrying

            finally:
                driver.quit()

        except Exception as e:
            print(f'Retry {retry}/{max_retries}: WebDriver initialization error - {e}')
            time.sleep(10 * retry)  # Increase the delay before retrying

    return None

def scan(url, headers=None, proxies=None):
    vulnerable_urls = []

    try:
        file_path = r'C:\Users\HP\OneDrive\Documents\SchoolWork\Semesters\Semester8\PythonGUI\vulnerabilities\sql.txt'

        with open(file_path, 'r') as file:
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                futures = []

                for line in file:
                    payload_url = f'{url}?id={line.strip()}'
                    futures.append(executor.submit(scan_payload, payload_url))
                    time.sleep(0.5)  # Increase the delay between requests

                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        vulnerable_urls.append(result)

        return (
            f'Vulnerable URLs: {vulnerable_urls}' if vulnerable_urls else 'No vulnerable URLs found',
            vulnerable_urls
        )

    except Exception as e:
        return f'Error: {e}', []

